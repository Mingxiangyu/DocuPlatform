# DocuVault 技术实现参考资料

## Context7 技术文档参考

### Vue 3 开发参考
基于Context7获取的Vue 3最佳实践：

**Composition API核心模式**:
```vue
<script setup>
import { ref, onMounted } from 'vue'

// 响应式状态
const count = ref(0)

// 状态变更函数
function increment() {
  count.value++
}

// 生命周期钩子
onMounted(() => {
  console.log(`初始计数: ${count.value}`)
})
</script>

<template>
  <button @click="increment">计数: {{ count }}</button>
</template>
```

**状态管理模式**:
```typescript
// Pinia store结构
export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const isAuthenticated = computed(() => !!user.value)
  
  const login = async (credentials: LoginCredentials) => {
    // 登录逻辑实现
  }
  
  return { user, isAuthenticated, login }
})
```

### Next.js App Router参考
基于Context7获取的Next.js现代化开发模式：

**App Router数据获取**:
```typescript
// 服务端组件数据获取
export default async function Page() {
  // 静态数据（类似getStaticProps）
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })
  
  // 动态数据（类似getServerSideProps）
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })
  
  // 重新验证数据
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 }
  })

  return <div>...</div>
}
```

**客户端组件模式**:
```tsx
'use client'

import { useRouter, usePathname, useSearchParams } from 'next/navigation'

export default function ClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()
  
  // 客户端逻辑
}
```

## 高保真原型转换指南

### 组件提取策略
基于现有HTML原型的组件化转换：

**1. 原子组件提取**:
```html
<!-- 原HTML按钮 -->
<button class="bg-purple-600 hover:bg-purple-700 text-white font-medium px-4 py-2 rounded-lg">
  立即购买
</button>

<!-- 转换为Vue组件 -->
<BaseButton variant="primary" size="medium">
  立即购买
</BaseButton>
```

**2. 分子组件提取**:
```html
<!-- 原HTML文章卡片 -->
<div class="article-card bg-white rounded-lg shadow p-6" data-component="article-card">
  <img src="..." class="w-full h-48 object-cover rounded-lg mb-4">
  <h3 class="text-xl font-semibold mb-2">文章标题</h3>
  <p class="text-gray-600 mb-4">文章摘要...</p>
  <div class="flex justify-between items-center">
    <span class="text-purple-600 font-semibold">¥29</span>
    <button class="btn-primary">立即购买</button>
  </div>
</div>

<!-- 转换为Vue组件 -->
<ArticleCard 
  :article="article"
  @purchase="handlePurchase"
/>
```

### 状态管理迁移
```javascript
// 原HTML中的JavaScript状态
let autoSaveTimer;
let formData = {};

function autoSave() {
  // 自动保存逻辑
}

// 转换为Vue Composition API
export function useAutoSave() {
  const autoSaveTimer = ref<NodeJS.Timeout>()
  const formData = ref({})
  
  const autoSave = () => {
    // 自动保存逻辑
  }
  
  return { formData, autoSave }
}
```

## 核心功能实现参考

### 文本高亮和笔记系统
```typescript
// 基于Range API的文本选择
export function useTextSelection() {
  const createHighlight = (range: Range, color: string) => {
    const span = document.createElement('span')
    span.className = `highlight-${color}`
    span.setAttribute('data-highlight-id', generateId())
    
    try {
      range.surroundContents(span)
      return span.getAttribute('data-highlight-id')
    } catch (error) {
      // 处理复杂选择的情况
      const contents = range.extractContents()
      span.appendChild(contents)
      range.insertNode(span)
      return span.getAttribute('data-highlight-id')
    }
  }
  
  const removeHighlight = (highlightId: string) => {
    const element = document.querySelector(`[data-highlight-id="${highlightId}"]`)
    if (element) {
      const parent = element.parentNode
      while (element.firstChild) {
        parent?.insertBefore(element.firstChild, element)
      }
      parent?.removeChild(element)
    }
  }
  
  return { createHighlight, removeHighlight }
}
```

### 支付系统集成
```typescript
// 支付状态管理
export function usePayment() {
  const paymentStatus = ref<'idle' | 'pending' | 'success' | 'failed'>('idle')
  const currentOrder = ref<PaymentOrder | null>(null)
  
  const createPayment = async (articleId: string) => {
    paymentStatus.value = 'pending'
    
    try {
      const order = await api.post('/api/payments/create', { articleId })
      currentOrder.value = order
      
      // 开始轮询支付状态
      startPaymentPolling(order.id)
      
      return order
    } catch (error) {
      paymentStatus.value = 'failed'
      throw error
    }
  }
  
  const startPaymentPolling = (orderId: string) => {
    const pollInterval = setInterval(async () => {
      try {
        const status = await api.get(`/api/payments/${orderId}/status`)
        
        if (status.paid) {
          paymentStatus.value = 'success'
          clearInterval(pollInterval)
        } else if (status.expired) {
          paymentStatus.value = 'failed'
          clearInterval(pollInterval)
        }
      } catch (error) {
        console.error('支付状态查询失败:', error)
      }
    }, 2000)
    
    // 5分钟后停止轮询
    setTimeout(() => clearInterval(pollInterval), 5 * 60 * 1000)
  }
  
  return { paymentStatus, currentOrder, createPayment }
}
```

### Markdown编辑器实现
```typescript
// Markdown编辑器组合式函数
export function useMarkdownEditor() {
  const content = ref('')
  const previewHtml = ref('')
  
  const updatePreview = debounce(() => {
    previewHtml.value = marked(content.value, {
      highlight: (code, lang) => {
        return hljs.highlight(code, { language: lang }).value
      }
    })
  }, 300)
  
  const insertMarkdown = (before: string, after: string = '') => {
    const textarea = editorRef.value
    const start = textarea.selectionStart
    const end = textarea.selectionEnd
    const selectedText = content.value.substring(start, end)
    
    const replacement = before + selectedText + after
    content.value = content.value.substring(0, start) + replacement + content.value.substring(end)
    
    // 更新光标位置
    nextTick(() => {
      textarea.focus()
      textarea.setSelectionRange(start + before.length, start + before.length + selectedText.length)
    })
  }
  
  const insertPaywall = () => {
    insertMarkdown('\n\n<!--more-->\n\n')
  }
  
  watch(content, updatePreview)
  
  return {
    content,
    previewHtml,
    insertMarkdown,
    insertPaywall
  }
}
```

## 数据库优化参考

### 索引策略
```sql
-- 文章搜索优化
CREATE INDEX idx_articles_search ON articles 
USING gin(to_tsvector('chinese', title || ' ' || content));

-- 用户笔记查询优化
CREATE INDEX idx_notes_user_article ON notes (user_id, article_id);
CREATE INDEX idx_notes_created ON notes (created_at DESC);

-- 订单查询优化
CREATE INDEX idx_orders_user_status ON orders (user_id, status);
CREATE INDEX idx_orders_created ON orders (created_at DESC);
```

### 查询优化
```sql
-- 高效的文章列表查询
SELECT a.*, u.nickname as author_name, c.name as category_name
FROM articles a
LEFT JOIN users u ON a.author_id = u.id
LEFT JOIN categories c ON a.category_id = c.id
WHERE a.status = 'published'
ORDER BY a.published_at DESC
LIMIT 20 OFFSET $1;

-- 用户购买权限检查
SELECT EXISTS(
  SELECT 1 FROM orders 
  WHERE user_id = $1 AND article_id = $2 AND status = 'paid'
) as has_access;
```

## 安全实施参考

### JWT实现
```typescript
// JWT工具函数
export const jwtUtils = {
  generateTokens: (userId: string) => {
    const accessToken = jwt.sign(
      { userId, type: 'access' },
      process.env.JWT_SECRET!,
      { expiresIn: '15m' }
    )
    
    const refreshToken = jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '7d' }
    )
    
    return { accessToken, refreshToken }
  },
  
  verifyToken: (token: string, type: 'access' | 'refresh') => {
    const secret = type === 'access' 
      ? process.env.JWT_SECRET! 
      : process.env.JWT_REFRESH_SECRET!
      
    return jwt.verify(token, secret) as JWTPayload
  }
}
```

### 输入验证
```typescript
// 数据验证schemas
export const validationSchemas = {
  register: z.object({
    email: z.string().email('邮箱格式不正确'),
    password: z.string()
      .min(8, '密码至少8位')
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, '密码必须包含大小写字母和数字'),
    nickname: z.string()
      .min(2, '昵称至少2位')
      .max(20, '昵称最多20位')
      .regex(/^[\u4e00-\u9fa5a-zA-Z0-9_]+$/, '昵称只能包含中文、字母、数字和下划线')
  }),
  
  article: z.object({
    title: z.string().min(5, '标题至少5个字符').max(500, '标题最多500个字符'),
    content: z.string().min(10, '内容至少10个字符'),
    excerpt: z.string().max(200, '摘要最多200个字符').optional(),
    price: z.number().min(0, '价格不能为负数').max(9999, '价格不能超过9999元').optional()
  })
}
```

## 部署和运维参考

### Docker配置
```dockerfile
# frontend/Dockerfile
FROM node:18-alpine as builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 监控配置
```typescript
// 性能监控
export const performanceMonitor = {
  trackPageLoad: (pageName: string) => {
    const startTime = performance.now()
    
    return () => {
      const loadTime = performance.now() - startTime
      analytics.track('page_load', {
        page: pageName,
        loadTime: Math.round(loadTime)
      })
    }
  },
  
  trackApiCall: (endpoint: string, method: string) => {
    const startTime = performance.now()
    
    return (success: boolean) => {
      const responseTime = performance.now() - startTime
      analytics.track('api_call', {
        endpoint,
        method,
        responseTime: Math.round(responseTime),
        success
      })
    }
  }
}
```

## 总结

本参考资料基于Context7技术文档和现有高保真原型，提供了详细的技术实现指导。开发团队应：

1. **严格遵循组件化架构**：确保代码的可维护性和复用性
2. **重视性能优化**：从开发阶段就考虑性能问题
3. **强化安全措施**：数据安全是知识付费平台的核心
4. **完善监控体系**：及时发现和解决问题

通过遵循这些最佳实践，可以构建出高质量、高性能、高安全性的DocuVault知识付费平台。
